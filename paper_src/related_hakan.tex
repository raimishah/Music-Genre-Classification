\section{Related Work}\label{sec:related}

{\em Instruction criticality} was researched by several studies where the focus was generally on a shared memory multiprocessor \cite{Lebeck:2003} or on a cross-layer approach \cite{Rehman:2016}. Tune et al presented an approach on Quantifying Instruction Criticality that predicts critical paths in a program and defines tautness as a measure of importance of critical instructions \cite{Tune:2002}. Fields have proposed a directed acyclic graph (DAG) model for characterizing program microexecutions on uniprocessors \cite{Fields:2001}. Under such a model, critical path analysis can be applied and instructions' slack values can be used to quantify
instruction criticality. Lebeck extends the uniprocessor DAG model to characterize parallel program executions on shared memory multiprocessor systems \cite{Lebeck:2003}. Finally, Semeen proposed a similar model for Reliability-Driven Selective Instruction Protection where instruction-level Error Masking Index (IMI) and Error Propagation Index (EPI) are defined to create a Reliability Profit Function for instruction criticality \cite{Rehman:2016}.

 Furthermore, reliable code generation was also the focus of many research projects. After his Selective Instruction Protection, Rehman Semeen proposed a multi-layer approach to achieve reliable code generation and execution at compilation and system software layers for embedded systems by building a schedule table offline to optimize the Reliability-Timing penalty \cite{RTPenalty:2013}. Besides these, Semeen also proposed a compilation tehcnique for reliability-aware software transformations where spatial and temporal vulnerability is considered \cite{Compilation_Rehman:2014}. Schwarz et al, on the other hand, presented a reliable software development methodology for safety related applications for reliable source code dependent on a simulation \cite{Schwarz:2009}. Finally, Excoffon et al discussed adaptive fault tolerance mechanisms (FTMs) and provided an estimation model for the quantification of the system's resilience or reliability where the impact of assumptions of FTM selection was thoroughly analyzed. \cite{FTM:2017}

 As compared to these works, our approach considers factors such as instruction location, loop count or instruction type to create a more efficient and fast algorithm for dependable code generation and instruction criticality. Specifically, compared to the Selective Instruction Protection work of Semeen \cite{Rehman:2016}, our approach focuses on each instruction's characteristics such as its location or type and considers the repeated usage in a loop. Furthermore, even though the Reliability Profit Function Semeen defined in his work is similar to our instruction criticality formula, we try to consider both data corruption and crash rates and give the user ability to concentrate more on one of the error types than the other. Our work not only provides flexibility to the user but also considers any possible instruction-level errors that might be encountered in an embedded system. 
  

